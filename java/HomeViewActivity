package com.project.innerpeace

import android.content.Context
import android.graphics.Color
import android.location.LocationManager
import android.os.AsyncTask
import android.os.Bundle
import android.util.Log
import android.view.Menu
import android.view.MenuItem
import androidx.appcompat.app.AppCompatActivity
import com.naver.maps.geometry.LatLng
import com.naver.maps.map.*
import com.naver.maps.map.overlay.InfoWindow
import com.naver.maps.map.overlay.Marker
import com.naver.maps.map.util.FusedLocationSource
import com.naver.maps.map.util.MarkerIcons
import org.json.JSONObject
import java.io.BufferedReader
import java.io.InputStreamReader
import java.net.URL
import java.util.*
import kotlin.collections.ArrayList


open class HomeViewActivity : AppCompatActivity(), OnMapReadyCallback {
    private lateinit var locationSource: FusedLocationSource
    private lateinit var naverMap: NaverMap
    open var publicToilet = ArrayList<PublicToilet>()
    private var gpsTracker: GpsTracker? = null
    var flag: Boolean = true
    var markersPosition = Vector<LatLng>()
    var activeMarkers = Vector<Marker>()
    var markersANAME = ArrayList<String>()
    var myLatitude: Double = 0.0
    var myLongitude: Double = 0.0


    inner class getPublicToilet() : AsyncTask<Any?, Any?, Any?>() {
        override fun doInBackground(vararg p0: Any?): Any? {
//            Log.d("json", "doInBackGround 시작")
            var temp: String = ""
            val url1: String =
                "http://openapi.seoul.go.kr:8088/707a4c4464646c61353662754a576c/json/SearchPublicToiletPOIService/1/100"    //원래는1000으로 하려고 했으나 쓰레드 타이밍이 안맞아서 일단 200으로 하기.
            val url2: String =
                "http://openapi.seoul.go.kr:8088/707a4c4464646c61353662754a576c/json/SearchPublicToiletPOIService/1001/2000"
            val url3: String =
                "http://openapi.seoul.go.kr:8088/707a4c4464646c61353662754a576c/json/SearchPublicToiletPOIService/2001/3000"
            val url4: String =
                "http://openapi.seoul.go.kr:8088/707a4c4464646c61353662754a576c/json/SearchPublicToiletPOIService/3001/4000"
            val url5: String =
                "http://openapi.seoul.go.kr:8088/707a4c4464646c61353662754a576c/json/SearchPublicToiletPOIService/4001/4938"


            try {
                val stream = URL(url1).openStream()
                val read = BufferedReader(InputStreamReader(stream, "UTF-8"))
                var line: String? = read.readLine()
                while (line != null) {
                    temp += (line)
                    line = read.readLine()
                }
            } catch (e: Exception) {
                Log.d("error", e.toString())
            }


            val json = JSONObject(temp)
            Log.d("json", "json객체 : " + json.toString())

            //count 임시지정
            val count = 100 //url1
            var SearchPublicToiletPOIService =
                json.getJSONObject("SearchPublicToiletPOIService")
            var row = SearchPublicToiletPOIService.getJSONArray("row")
            Log.d("json", row.toString())
            for (i in 0..(count - 1)) {
                val rowObject = row.getJSONObject(i)
                publicToilet.add(
                    PublicToilet(
                        rowObject.getDouble("Y_WGS84"),
                        rowObject.getString("INSERTDATE"),
                        rowObject.getDouble("X_WGS84"),
                        rowObject.getDouble("CENTER_Y1"),
                        rowObject.getDouble("CENTER_X1"),
                        rowObject.getString("UPDATEDATE"),
                        rowObject.getString("POI_ID"),
                        rowObject.getString("CNAME"),
                        rowObject.getString("ANAME"),
                        rowObject.getString("FNAME")
                    )
                )
            }
//
//            Log.d("json", "doInBackGround 끝")
//            Log.d("json", "publicToiletArray : "+publicToilet.toString())
            return publicToilet


        }

        override fun onPostExecute(result: Any?) {
            super.onPostExecute(result)
//            Log.d("json", "onPostExecute 시작")
//            Log.d("json", publicToilet.toString())
//            Log.d("json", "onPostExecute 끝")

        }


    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Log.d("json", "onCreate 시작")

        //뷰 set
        setContentView(R.layout.activity_home_view)
        setSupportActionBar(findViewById(R.id.my_toolbar))

        //내 현재위치 좌표
        gpsTracker = GpsTracker(this@HomeViewActivity)
        this.myLatitude = gpsTracker!!.latitude
        this.myLongitude = gpsTracker!!.longitude
//        Log.d("locat", "myLatitude : "+myLatitude.toString() + "myLongitude : "+ myLongitude.toString())

        //ToolBar
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        supportActionBar?.setHomeButtonEnabled(true)
        supportActionBar?.setDisplayShowTitleEnabled(false)

        //서버에서 정보 가져와 리스트에 저장
        getPublicToilet().execute()

        //네이버 지도 객체 불러오기
        val fm = supportFragmentManager
        val mapFragment = fm.findFragmentById(R.id.map_fragment_container) as MapFragment?
            ?: MapFragment.newInstance().also {
                fm.beginTransaction().add(R.id.map_fragment_container, it).commit()
            }
        mapFragment.getMapAsync(this)

        //현재위치 가져오기 -> 네이버 tracker용
        locationSource =
            FusedLocationSource(this, LOCATION_PERMISSION_REQUEST_CODE)

        Log.d("json", "onCreate 끝")
        
         //각 버튼 누를 때 화면 전환
        allToilet.setOnClickListener {
            startActivity(Intent(this@HomeViewActivity, A_All_view::class.java))
        }
        metroToilet.setOnClickListener {
            startActivity(Intent(this@HomeViewActivity, B_Sub_view::class.java))
        }
        cafeToilet.setOnClickListener {
            startActivity(Intent(this@HomeViewActivity, E_Cafe_view::class.java))
        }
        restaurantToilet.setOnClickListener {
            startActivity(Intent(this@HomeViewActivity, D_Food_view::class.java))
        }
        BarToilet.setOnClickListener {
            startActivity(Intent(this@HomeViewActivity, F_Beer_view::class.java))
        }
        MarketToilet.setOnClickListener {
            startActivity(Intent(this@HomeViewActivity, C_Mart_view::class.java))
        }
        
        //GPS_view에서의 사용자 입력 값을 inputString 변수에 전달받음
        val inputString = intent.getStringExtra("input")
    }


    //위치정보 허가 여부
    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array<out String>,
        grantResults: IntArray
    ) {
        if (locationSource.onRequestPermissionsResult(
                requestCode, permissions,
                grantResults
            )
        ) {

            if (!locationSource.isActivated) { // 권한 거부됨
                naverMap.locationTrackingMode = LocationTrackingMode.None
//                Log.d("map_permit","권한 거부됨")
            }
            return
        }
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
    }

    //지도 표시
    override fun onMapReady(naverMap: NaverMap) {
        Log.d("json", "onMapReady 시작")
        this.naverMap = naverMap

        // 카메라 초기 위치 설정
        val initialPosition = LatLng(37.506855, 127.066242)
        val cameraUpdate: CameraUpdate = CameraUpdate.scrollTo(initialPosition)
        naverMap.moveCamera(cameraUpdate)

        //현재위치(파란 동그라미) 보이게 하기
        var locationOverlay = naverMap.locationOverlay
        locationOverlay.isVisible = true    //오버레이 보이게 하기
        naverMap.locationSource = locationSource
        naverMap.locationTrackingMode = LocationTrackingMode.Follow     //현재위치 추적모드

//        //마커 클릭하면 태그 보이기
//        val infoWindow = InfoWindow()
//        infoWindow.adapter = object : InfoWindow.DefaultTextAdapter(this) {
//            override fun getText(p0: InfoWindow): CharSequence {
//                return infoWindow.marker?.tag as CharSequence? ?: ""
//            }
//        }

//        //서버에서 가져온 리스트 정보로 마커 만들기
//        Log.d("json", "this.publicToilet : " + this.publicToilet.toString() + "찐1")
//        val markers = mutableMapOf<String, LatLng>()

//        this.publicToilet?.forEach {
//            markersPosition.add(LatLng(it.Y_WGS84, it.X_WGS84))
//            markers += Marker().apply {
//                position = LatLng(it.Y_WGS84, it.X_WGS84)
//                icon = MarkerIcons.BLACK
//                if (it.ANAME == "민간개방화장실") {
//                    iconTintColor = Color.YELLOW
//                }
//                if (it.ANAME == "공공청사") {    //주민센터, 지구대, 공영 주차장 등
//                    iconTintColor = Color.BLUE
//                }
//                if (it.ANAME == "개방") {  // 은행, 프라자, 빌딩, 쇼핑몰
//                    iconTintColor = Color.GREEN
//                }
//                if (it.ANAME == "공중") {  //공원 공중화장실
//                    iconTintColor = Color.DKGRAY
//                }
//                if (it.ANAME == "공공기관") {    // 주민센터, 보건소, 파출소
//                    iconTintColor = Color.CYAN
//                }
//                if (it.ANAME == "지하철") {  // 지하철
//                    iconTintColor = Color.GRAY
//                }
//                width = Marker.SIZE_AUTO
//                height = Marker.SIZE_AUTO
//
////                setOnClickListener {
////                    infoWindow.open(this)
////                    true
////                }
//            }
//            markers.forEach { marker ->
//                marker.map = naverMap
//            }
//        }

        this.publicToilet?.forEach {
            markersPosition.add(LatLng(it.Y_WGS84, it.X_WGS84))
            markersANAME.add(it.ANAME)
//            markers.put(it.ANAME, LatLng(it.Y_WGS84, it.X_WGS84))
        }
//        Log.d("json", "markers : " + markers.toString() )

//        fun setMarkerIconColor(aname: String, marker: Marker) {
//            when (aname) {
//                "민간개방화장실" -> marker.iconTintColor = Color.YELLOW
//                "공공청사" -> marker.iconTintColor = Color.BLUE
//                "개방" -> marker.iconTintColor = Color.GREEN
//                "공중" -> marker.iconTintColor = Color.DKGRAY
//                "공공기관" -> marker.iconTintColor = Color.CYAN
//                "지하철" -> marker.iconTintColor = Color.GRAY
//            }
//        }

        // 카메라 이동 되면 호출 되는 이벤트
        naverMap.addOnCameraChangeListener { reason, animated ->
            freeActiveMarkers()
            val currentPosition = getCurrentPosition(naverMap)
            // 정의된 마커위치들중 가시거리 내에있는것들만 마커 생성
            for (markerPosition in markersPosition) {
                val marker = Marker()
                if (!withinSightMarker(currentPosition, markerPosition!!)) continue //카메라 가시거리 안에 없으면 continue
                marker.position = markerPosition!!
                marker.icon = MarkerIcons.BLACK
                marker.map = naverMap
                activeMarkers.add(marker)
//                marker.apply {
//                    if (markerANAME == "민간개방화장실") {
//                        iconTintColor = Color.YELLOW
//                    }
//                    if (markerANAME == "공공청사") {    //주민센터, 지구대, 공영 주차장 등
//                        iconTintColor = Color.BLUE
//                    }
//                    if (markerANAME == "개방") {  // 은행, 프라자, 빌딩, 쇼핑몰
//                        iconTintColor = Color.GREEN
//                    }
//                    if (markerANAME == "공중") {  //공원 공중화장실
//                        iconTintColor = Color.DKGRAY
//                    }
//                    if (markerANAME == "공공기관") {    // 주민센터, 보건소, 파출소
//                        iconTintColor = Color.CYAN
//                    }
//                    if (markerANAME == "지하철") {  // 지하철
//                        iconTintColor = Color.GRAY
//                    }
//                    width = Marker.SIZE_AUTO
//                    height = Marker.SIZE_AUTO
//                }

//                setMarkerIconColor(aname, marker)


            }



        }




        Log.d("json", "onMapReady 끝")
//        Log.d("json", markersPosition.toString())
    }



    // 지도상에 표시되고있는 마커들 지도에서 삭제
    fun freeActiveMarkers() {
        if (activeMarkers == null) {
            activeMarkers = Vector<Marker>()
            return
        }
        for (activeMarker in activeMarkers) {
            activeMarker.map = null
        }
        activeMarkers = Vector<Marker>()
    }


    // 현재 카메라가 보고있는 위치
    open fun getCurrentPosition(naverMap: NaverMap): LatLng {
        val cameraPosition = naverMap.cameraPosition
        return LatLng(cameraPosition.target.latitude, cameraPosition.target.longitude)
    }

    val REFERANCE_LAT_X3 = 3 / 109.958489129649955
    val REFERANCE_LNG_X3 = 3 / 88.74
    open fun withinSightMarker(currentPosition: LatLng, markerPosition: LatLng ): Boolean {
        val withinSightMarkerLat: Boolean =
            Math.abs(currentPosition.latitude - markerPosition.latitude) <= REFERANCE_LAT_X3
        val withinSightMarkerLng: Boolean =
            Math.abs(currentPosition.longitude - markerPosition.longitude) <= REFERANCE_LNG_X3
        return withinSightMarkerLat && withinSightMarkerLng
    }

//    private fun checkLocationServicesStatus(): Boolean {
//        val locationManager =
//            getSystemService(Context.LOCATION_SERVICE) as LocationManager
//        return (locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)
//                || locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER))
//    }


    companion object {
        private const val LOCATION_PERMISSION_REQUEST_CODE = 1000
//        private const val GPS_ENABLE_REQUEST_CODE = 2001
//        private const val PERMISSIONS_REQUEST_CODE = 100
    }


    //ToolBar
    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        val id = item.itemId
        when (id) {
            android.R.id.home -> {
                finish()
                return true
            }
        }
        return super.onOptionsItemSelected(item)
    }

    override fun onCreateOptionsMenu(menu: Menu): Boolean {
        val inflater = menuInflater
        inflater.inflate(R.menu.menu, menu)
        return true
    }


}




